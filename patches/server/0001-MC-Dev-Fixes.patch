From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Mon, 29 Nov 2021 22:02:06 +1000
Subject: [PATCH] MC-Dev Fixes


diff --git a/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java b/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java
index f7c856535cc6a1f010d82f0a0b31a34978854310..909a95d279ebb4727111d3bd6bc0f9faca7c69f2 100644
--- a/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java
+++ b/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java
@@ -112,8 +112,8 @@ public class ArgumentTypeInfos {
         register(registry, "entity_summon", EntitySummonArgument.class, SingletonArgumentInfo.contextFree(EntitySummonArgument::id));
         register(registry, "dimension", DimensionArgument.class, SingletonArgumentInfo.contextFree(DimensionArgument::dimension));
         register(registry, "time", TimeArgument.class, SingletonArgumentInfo.contextFree(TimeArgument::time));
-        register(registry, "resource_or_tag", fixClassType(ResourceOrTagLocationArgument.class), new ResourceOrTagLocationArgument.Info());
-        register(registry, "resource", fixClassType(ResourceKeyArgument.class), new ResourceKeyArgument.Info());
+        register(registry, "resource_or_tag", fixClassType(ResourceOrTagLocationArgument.class), new ResourceOrTagLocationArgument.Info<>());
+        register(registry, "resource", fixClassType(ResourceKeyArgument.class), new ResourceKeyArgument.Info<>());
         register(registry, "template_mirror", TemplateMirrorArgument.class, SingletonArgumentInfo.contextFree(TemplateMirrorArgument::templateMirror));
         register(registry, "template_rotation", TemplateRotationArgument.class, SingletonArgumentInfo.contextFree(TemplateRotationArgument::templateRotation));
         if (SharedConstants.IS_RUNNING_IN_IDE) {
@@ -125,7 +125,7 @@ public class ArgumentTypeInfos {
     }
 
     private static <T extends ArgumentType<?>> Class<T> fixClassType(Class<? super T> clazz) {
-        return clazz;
+        return (Class<T>) clazz; // MultiPaper - fix decompile error
     }
 
     public static boolean isClassRecognized(Class<?> clazz) {
@@ -137,7 +137,7 @@ public class ArgumentTypeInfos {
         if (argumentTypeInfo == null) {
             throw new IllegalArgumentException("Unrecognized argument type %s (%s)".formatted(argumentType, argumentType.getClass()));
         } else {
-            return argumentTypeInfo;
+            return (ArgumentTypeInfo<A, ?>) argumentTypeInfo; //MultiPaper - fix decompile error
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/Brain.java b/src/main/java/net/minecraft/world/entity/ai/Brain.java
index 1a4db35de5a37658427f35942fdc2b546ab21dd2..e3a7f5d0ca54167e79c3aafbbe8b53a5a61408e1 100644
--- a/src/main/java/net/minecraft/world/entity/ai/Brain.java
+++ b/src/main/java/net/minecraft/world/entity/ai/Brain.java
@@ -71,15 +71,15 @@ public class Brain<E extends LivingEntity> {
             }
 
             public <T> DataResult<Brain<E>> decode(DynamicOps<T> dynamicOps, MapLike<T> mapLike) {
-                MutableObject<DataResult<ImmutableList.Builder<Brain.MemoryValue<?>>>> mutableObject = new MutableObject<>(DataResult.success(ImmutableList.builder()));
+                MutableObject<DataResult<ImmutableList.Builder<Brain.MemoryValue<?>>>> mutableObject2 = new MutableObject<>(DataResult.success(ImmutableList.builder())); // Airplane - fix decompiler error
                 mapLike.entries().forEach((pair) -> {
                     DataResult<MemoryModuleType<?>> dataResult = Registry.MEMORY_MODULE_TYPE.byNameCodec().parse(dynamicOps, pair.getFirst());
                     DataResult<? extends Brain.MemoryValue<?>> dataResult2 = dataResult.flatMap((memoryModuleType) -> {
                         return this.captureRead(memoryModuleType, dynamicOps, (T)pair.getSecond());
                     });
-                    mutableObject.setValue(mutableObject.getValue().apply2(ImmutableList.Builder::add, dataResult2));
+                    mutableObject2.setValue(mutableObject2.getValue().apply2(ImmutableList.Builder::add, dataResult2)); // Airplane - fix decompiler error
                 });
-                ImmutableList<Brain.MemoryValue<?>> immutableList = mutableObject.getValue().resultOrPartial(Brain.LOGGER::error).map(ImmutableList.Builder::build).orElseGet(ImmutableList::of);
+                ImmutableList<Brain.MemoryValue<?>> immutableList = mutableObject2.getValue().resultOrPartial(Brain.LOGGER::error).map(ImmutableList.Builder::build).orElseGet(ImmutableList::of); // Airplane - fix decompiler error
                 return DataResult.success(new Brain<>(memoryModules, sensors, immutableList, mutableObject::getValue));
             }
 
@@ -168,12 +168,7 @@ public class Brain<E extends LivingEntity> {
     }
 
     public <U> Optional<U> getMemory(MemoryModuleType<U> type) {
-        Optional<? extends ExpirableValue<?>> optional = this.memories.get(type);
-        if (optional == null) {
-            throw new IllegalStateException("Unregistered memory fetched: " + type);
-        } else {
-            return optional.map(ExpirableValue::getValue);
-        }
+        return (Optional<U>) this.memories.get(type).map(ExpirableValue::getValue); // Airplane - compile fix
     }
 
     public <U> long getTimeUntilExpiry(MemoryModuleType<U> type) {
@@ -468,7 +463,7 @@ public class Brain<E extends LivingEntity> {
         private final Optional<? extends ExpirableValue<U>> value;
 
         static <U> Brain.MemoryValue<U> createUnchecked(MemoryModuleType<U> type, Optional<? extends ExpirableValue<?>> data) {
-            return new Brain.MemoryValue<>(type, data);
+            return new Brain.MemoryValue<>(type, (Optional) data); // Airplane - compile fix
         }
 
         MemoryValue(MemoryModuleType<U> type, Optional<? extends ExpirableValue<U>> data) {
