From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sat, 29 Jan 2022 20:22:06 +1000
Subject: [PATCH] Only save non-modified chunks


diff --git a/src/main/java/ca/spottedleaf/starlight/common/light/StarLightEngine.java b/src/main/java/ca/spottedleaf/starlight/common/light/StarLightEngine.java
index 1b0d92c68407cdb09ed8aac271b625d92db87017..5ff206a1e92c13312989e07b2154bc0787da5599 100644
--- a/src/main/java/ca/spottedleaf/starlight/common/light/StarLightEngine.java
+++ b/src/main/java/ca/spottedleaf/starlight/common/light/StarLightEngine.java
@@ -427,6 +427,8 @@ public abstract class StarLightEngine {
                 this.propagateBlockChanges(lightAccess, chunk, positions);
             }
             this.updateVisible(lightAccess);
+
+            chunk.setUnsaved(true); // MultiPaper
         } finally {
             this.destroyCaches();
         }
@@ -906,6 +908,8 @@ public abstract class StarLightEngine {
             this.lightChunk(lightAccess, chunk, true);
             this.setNibbles(chunk, nibbles);
             this.updateVisible(lightAccess);
+
+            chunk.setUnsaved(true); // MultiPaper
         } finally {
             this.destroyCaches();
         }
@@ -1004,6 +1008,8 @@ public abstract class StarLightEngine {
                     }
 
                     this.lightChunk(lightAccess, neighbour, false);
+
+                    neighbour.setUnsaved(true); // MultiPaper
                 } finally {
                     this.destroyCaches();
                 }
@@ -1028,6 +1034,8 @@ public abstract class StarLightEngine {
                 chunkLightCallback.accept(chunkPos);
             }
             ++lightCalls;
+
+            chunk.setUnsaved(true); // MultiPaper
         }
 
         if (onComplete != null) {
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 0f01607f78dfbc72e22c4d913dbe130c5bc13df6..e8347b625be246a03e7e4ca34b393ccbc15ed604 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -591,7 +591,7 @@ public class ChunkHolder {
                         // Minecraft will apply the chunks tick lists to the world once the chunk got loaded, and then store the tick
                         // lists again inside the chunk once the chunk becomes inaccessible and set the chunk's needsSaving flag.
                         // These actions may however happen deferred, so we manually set the needsSaving flag already here.
-                        chunk.setUnsaved(true);
+                        // chunk.setUnsaved(true); // MultiPaper - not convinced ^
                         chunk.unloadCallback();
                     });
                 }
diff --git a/src/main/java/net/minecraft/world/level/LevelAccessor.java b/src/main/java/net/minecraft/world/level/LevelAccessor.java
index 9c0a6b836de9cc8309776317760d0469e8fc345c..21c178c868a7ab2e0837b9d0aed954f9e3a8a981 100644
--- a/src/main/java/net/minecraft/world/level/LevelAccessor.java
+++ b/src/main/java/net/minecraft/world/level/LevelAccessor.java
@@ -15,6 +15,7 @@ import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkSource;
+import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.redstone.NeighborUpdater;
@@ -45,11 +46,13 @@ public interface LevelAccessor extends CommonLevelAccessor, LevelTimeAccess {
     }
 
     default void scheduleTick(BlockPos pos, Block block, int delay, TickPriority priority) {
+        if (this.getChunkIfLoadedImmediately(pos.getX() >> 4, pos.getZ() >> 4) instanceof LevelChunk levelChunk) levelChunk.setUnsaved(true); // MultiPaper
         MultiPaperExternalBlocksHandler.onBlockScheduled(getMinecraftWorld(), pos);
         this.getBlockTicks().schedule(this.createTick(pos, block, delay, priority));
     }
 
     default void scheduleTick(BlockPos pos, Block block, int delay) {
+        if (this.getChunkIfLoadedImmediately(pos.getX() >> 4, pos.getZ() >> 4) instanceof LevelChunk levelChunk) levelChunk.setUnsaved(true); // MultiPaper
         MultiPaperExternalBlocksHandler.onBlockScheduled(getMinecraftWorld(), pos);
         this.getBlockTicks().schedule(this.createTick(pos, block, delay));
     }
@@ -57,11 +60,13 @@ public interface LevelAccessor extends CommonLevelAccessor, LevelTimeAccess {
     LevelTickAccess<Fluid> getFluidTicks();
 
     default void scheduleTick(BlockPos pos, Fluid fluid, int delay, TickPriority priority) {
+        if (this.getChunkIfLoadedImmediately(pos.getX() >> 4, pos.getZ() >> 4) instanceof LevelChunk levelChunk) levelChunk.setUnsaved(true); // MultiPaper
         MultiPaperExternalBlocksHandler.onBlockScheduled(getMinecraftWorld(), pos);
         this.getFluidTicks().schedule(this.createTick(pos, fluid, delay, priority));
     }
 
     default void scheduleTick(BlockPos pos, Fluid fluid, int delay) {
+        if (this.getChunkIfLoadedImmediately(pos.getX() >> 4, pos.getZ() >> 4) instanceof LevelChunk levelChunk) levelChunk.setUnsaved(true); // MultiPaper
         MultiPaperExternalBlocksHandler.onBlockScheduled(getMinecraftWorld(), pos);
         this.getFluidTicks().schedule(this.createTick(pos, fluid, delay));
     }
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
index dcb919687740661b13004fcb484386a2de374429..ef6ece8931a9ba60e7859c072de894a9de0ac3c3 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
@@ -102,7 +102,8 @@ public class ChunkSerializer {
     private static final String STARLIGHT_VERSION_TAG = "starlight.light_version";
     // Paper end - replace light engine impl
 
-    public ChunkSerializer() {}
+    public ChunkSerializer() {
+    }
 
     // Paper start - guard against serializing mismatching coordinates
     // TODO Note: This needs to be re-checked each update
@@ -115,6 +116,7 @@ public class ChunkSerializer {
             return new ChunkPos(chunkData.getInt("xPos"), chunkData.getInt("zPos"));
         }
     }
+
     // Paper end
     // Paper start
     public static final class InProgressChunkHolder {
@@ -141,6 +143,7 @@ public class ChunkSerializer {
     // Paper start
     private static final int CURRENT_DATA_VERSION = SharedConstants.getCurrentVersion().getDataVersion().getVersion();
     private static final boolean JUST_CORRUPT_IT = Boolean.getBoolean("Paper.ignoreWorldDataVersion");
+
     // Paper end
     public static InProgressChunkHolder loadChunk(ServerLevel world, PoiManager poiStorage, ChunkPos chunkPos, CompoundTag nbt, boolean distinguish) {
         java.util.ArrayDeque<Runnable> tasksToExecuteOnMain = new java.util.ArrayDeque<>();
@@ -182,7 +185,8 @@ public class ChunkSerializer {
         DataResult dataresult;
 
         for (int j = 0; j < nbttaglist.size(); ++j) {
-            CompoundTag nbttagcompound1 = nbttaglist.getCompound(j); CompoundTag sectionData = nbttagcompound1; // Paper
+            CompoundTag nbttagcompound1 = nbttaglist.getCompound(j);
+            CompoundTag sectionData = nbttagcompound1; // Paper
             byte b0 = nbttagcompound1.getByte("Y");
             int k = world.getSectionIndexFromSectionY(b0);
 
@@ -222,7 +226,7 @@ public class ChunkSerializer {
 
                 achunksection[k] = chunksection;
                 tasksToExecuteOnMain.add(() -> { // Paper - delay this task since we're executing off-main
-                poiStorage.checkConsistencyWithBlocks(chunkPos, chunksection);
+                    poiStorage.checkConsistencyWithBlocks(chunkPos, chunksection);
                 }); // Paper - delay this task since we're executing off-main
             }
 
@@ -232,37 +236,37 @@ public class ChunkSerializer {
             // Paper start - rewrite the light engine
             if (flag) {
                 try {
-                if ((flag3 || flag4) && !flag2) {
-                    // Paper end - rewrite the light engine
-                    tasksToExecuteOnMain.add(() -> { // Paper - delay this task since we're executing off-main
-                    lightengine.retainData(chunkPos, true);
-                    }); // Paper - delay this task since we're executing off-main
-                    flag2 = true;
-                }
+                    if ((flag3 || flag4) && !flag2) {
+                        // Paper end - rewrite the light engine
+                        tasksToExecuteOnMain.add(() -> { // Paper - delay this task since we're executing off-main
+                            lightengine.retainData(chunkPos, true);
+                        }); // Paper - delay this task since we're executing off-main
+                        flag2 = true;
+                    }
 
-                int y = sectionData.getByte("Y");
-                if (flag3) {
-                    // Paper start - rewrite the light engine
-                    // this is where our diff is
-                    blockNibbles[y - minSection] = new ca.spottedleaf.starlight.common.light.SWMRNibbleArray(sectionData.getByteArray("BlockLight").clone(), sectionData.getInt(BLOCKLIGHT_STATE_TAG)); // clone for data safety
-                } else {
-                    blockNibbles[y - minSection] = new ca.spottedleaf.starlight.common.light.SWMRNibbleArray(null, sectionData.getInt(BLOCKLIGHT_STATE_TAG));
-                }
-                // Paper end - rewrite the light engine
+                    int y = sectionData.getByte("Y");
+                    if (flag3) {
+                        // Paper start - rewrite the light engine
+                        // this is where our diff is
+                        blockNibbles[y - minSection] = new ca.spottedleaf.starlight.common.light.SWMRNibbleArray(sectionData.getByteArray("BlockLight").clone(), sectionData.getInt(BLOCKLIGHT_STATE_TAG)); // clone for data safety
+                    } else {
+                        blockNibbles[y - minSection] = new ca.spottedleaf.starlight.common.light.SWMRNibbleArray(null, sectionData.getInt(BLOCKLIGHT_STATE_TAG));
+                    }
+                    // Paper end - rewrite the light engine
 
-                if (flag4) {
+                    if (flag4) {
+                        // Paper start - rewrite the light engine
+                        // we store under the same key so mod programs editing nbt
+                        // can still read the data, hopefully.
+                        // however, for compatibility we store chunks as unlit so vanilla
+                        // is forced to re-light them if it encounters our data. It's too much of a burden
+                        // to try and maintain compatibility with a broken and inferior skylight management system.
+                        skyNibbles[y - minSection] = new ca.spottedleaf.starlight.common.light.SWMRNibbleArray(sectionData.getByteArray("SkyLight").clone(), sectionData.getInt(SKYLIGHT_STATE_TAG)); // clone for data safety
+                    } else if (flag1) {
+                        skyNibbles[y - minSection] = new ca.spottedleaf.starlight.common.light.SWMRNibbleArray(null, sectionData.getInt(SKYLIGHT_STATE_TAG));
+                    }
+                    // Paper end - rewrite the light engine
                     // Paper start - rewrite the light engine
-                    // we store under the same key so mod programs editing nbt
-                    // can still read the data, hopefully.
-                    // however, for compatibility we store chunks as unlit so vanilla
-                    // is forced to re-light them if it encounters our data. It's too much of a burden
-                    // to try and maintain compatibility with a broken and inferior skylight management system.
-                    skyNibbles[y - minSection] = new ca.spottedleaf.starlight.common.light.SWMRNibbleArray(sectionData.getByteArray("SkyLight").clone(), sectionData.getInt(SKYLIGHT_STATE_TAG)); // clone for data safety
-                } else if (flag1) {
-                    skyNibbles[y - minSection] = new ca.spottedleaf.starlight.common.light.SWMRNibbleArray(null, sectionData.getInt(SKYLIGHT_STATE_TAG));
-                }
-                // Paper end - rewrite the light engine
-                // Paper start - rewrite the light engine
                 } catch (Exception ex) {
                     LOGGER.warn("Failed to load light data for chunk " + chunkPos + " in world '" + world.getWorld().getName() + "', light will be regenerated", ex);
                     flag = false;
@@ -296,11 +300,11 @@ public class ChunkSerializer {
             }, chunkPos);
 
             object1 = new LevelChunk(world.getLevel(), chunkPos, chunkconverter, levelchunkticks, levelchunkticks1, l, achunksection, ChunkSerializer.postLoadChunk(world, nbt), blendingdata);
-            ((LevelChunk)object1).setBlockNibbles(blockNibbles); // Paper - replace light impl
-            ((LevelChunk)object1).setSkyNibbles(skyNibbles); // Paper - replace light impl
+            ((LevelChunk) object1).setBlockNibbles(blockNibbles); // Paper - replace light impl
+            ((LevelChunk) object1).setSkyNibbles(skyNibbles); // Paper - replace light impl
             // MultiPaper start - Keep copy of entities and block entities until they're loaded
-            ((LevelChunk)object).entitiesToLoad = ChunkSerializer.getListOfCompoundsOrNull(nbt, "entities");
-            ((LevelChunk)object).blockEntitiesToLoad = ChunkSerializer.getListOfCompoundsOrNull(nbt, "block_entities");
+            ((LevelChunk) object1).entitiesToLoad = ChunkSerializer.getListOfCompoundsOrNull(nbt, "entities");
+            ((LevelChunk) object1).blockEntitiesToLoad = ChunkSerializer.getListOfCompoundsOrNull(nbt, "block_entities");
             // MultiPaper end
         } else {
             ProtoChunkTicks<Block> protochunkticklist = ProtoChunkTicks.load(nbt.getList("block_ticks", 10), (s) -> {
@@ -456,13 +460,14 @@ public class ChunkSerializer {
 
     // Paper start - async chunk save for unload
     public record AsyncSaveData(
-        DataLayer[] blockLight,
-        DataLayer[] skyLight,
-        Tag blockTickList, // non-null if we had to go to the server's tick list
-        Tag fluidTickList, // non-null if we had to go to the server's tick list
-        ListTag blockEntities,
-        long worldTime
-    ) {}
+            DataLayer[] blockLight,
+            DataLayer[] skyLight,
+            Tag blockTickList, // non-null if we had to go to the server's tick list
+            Tag fluidTickList, // non-null if we had to go to the server's tick list
+            ListTag blockEntities,
+            long worldTime
+    ) {
+    }
 
     // must be called sync
     public static AsyncSaveData getAsyncSaveData(ServerLevel world, ChunkAccess chunk) {
@@ -502,12 +507,12 @@ public class ChunkSerializer {
         }
 
         return new AsyncSaveData(
-            blockLight,
-            skyLight,
-            tickLists.get(BLOCK_TICKS_TAG),
-            tickLists.get(FLUID_TICKS_TAG),
-            blockEntitiesSerialized,
-            world.getGameTime()
+                blockLight,
+                skyLight,
+                tickLists.get(BLOCK_TICKS_TAG),
+                tickLists.get(FLUID_TICKS_TAG),
+                blockEntitiesSerialized,
+                world.getGameTime()
         );
     }
     // Paper end
@@ -530,6 +535,7 @@ public class ChunkSerializer {
         // Paper start
         return saveChunk(world, chunk, null);
     }
+
     public static CompoundTag saveChunk(ServerLevel world, ChunkAccess chunk, @org.checkerframework.checker.nullness.qual.Nullable AsyncSaveData asyncsavedata) {
         // Paper end
         // Paper start - rewrite light impl
@@ -597,7 +603,8 @@ public class ChunkSerializer {
             ca.spottedleaf.starlight.common.light.SWMRNibbleArray.SaveState skyNibble = skyNibbles[i - minSection].getSaveState();
             if (flag1 || blockNibble != null || skyNibble != null) {
                 // Paper end - replace light engine
-                CompoundTag nbttagcompound1 = new CompoundTag(); CompoundTag section = nbttagcompound1; // Paper
+                CompoundTag nbttagcompound1 = new CompoundTag();
+                CompoundTag section = nbttagcompound1; // Paper
 
                 if (flag1) {
                     LevelChunkSection chunksection = achunksection[j];
@@ -699,7 +706,7 @@ public class ChunkSerializer {
             nbttagcompound.put(BLOCK_TICKS_TAG, asyncsavedata.blockTickList);
             nbttagcompound.put(FLUID_TICKS_TAG, asyncsavedata.fluidTickList);
         } else {
-        ChunkSerializer.saveTicks(world, nbttagcompound, chunk.getTicksForSerialization());
+            ChunkSerializer.saveTicks(world, nbttagcompound, chunk.getTicksForSerialization());
         }
         // Paper end
         nbttagcompound.put("PostProcessing", ChunkSerializer.packOffsets(chunk.getPostProcessing()));
